(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{507:function(t,v,e){"use strict";e.r(v);var s=e(69),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"evolution-演变"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#evolution-演变"}},[t._v("#")]),t._v(" Evolution（演变）")]),t._v(" "),e("p",[t._v("Iceberg 支持表的原地演变。即使在嵌套结构中或者数据量变化时的分区布局变化，用户依旧可以像 SQL 一样演变表的 Schema。Iceberg 不受高昂代价的干扰，如重写表数据或者迁移数据至新表。")]),t._v(" "),e("div",{staticClass:"custom-block info"},[e("p",{staticClass:"custom-block-title"},[t._v("INFO")]),t._v(" "),e("p",[t._v("例如，Hive 表的分区无法更改，所以从每天分区迁移数据至每小时分区，必须创建新的表。由于查询依赖ß分区，必须为新表重写查询语句。某些情况下，即使是重命名列这样的操作也是不支持的。")]),t._v(" "),e("p",[t._v("然而，Iceberg 就没有这样的担心")])]),t._v(" "),e("h2",{attrs:{id:"schema-evolution-格式演变"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#schema-evolution-格式演变"}},[t._v("#")]),t._v(" Schema Evolution（格式演变）")]),t._v(" "),e("p",[t._v("Iceberg 支持以下 Schema 的更改：")]),t._v(" "),e("ul",[e("li",[t._v("add：向表或者嵌套结构中添加新的列")]),t._v(" "),e("li",[t._v("drop：删除表或者嵌套结构中的已存在的列")]),t._v(" "),e("li",[t._v("rename：重命名表或者嵌套结构中已存在的列或者字段")]),t._v(" "),e("li",[t._v("update：更改列、结构字段、 映射键、映射值 或者 list 元素的类型")]),t._v(" "),e("li",[t._v("reorder：更改嵌套结构中列或字段的顺序")])]),t._v(" "),e("div",{staticClass:"custom-block info"},[e("p",{staticClass:"custom-block-title"},[t._v("INFO")]),t._v(" "),e("p",[t._v("Iceberg 的 Schema 更新是"),e("strong",[t._v("对元数据的更改")]),t._v("，所以无需重写任何数据文件即可执行更新")])]),t._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),e("p",[t._v("映射键不支持添加和删除结构字段，因为这将使 "),e("strong",[t._v("相等性")]),t._v(" 发生变化")])]),t._v(" "),e("h3",{attrs:{id:"正确性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正确性"}},[t._v("#")]),t._v(" 正确性")]),t._v(" "),e("p",[t._v("Iceberg 保证 Schema Evolution 是"),e("strong",[t._v("独立并且无副作用的")]),t._v("，无需重写数据文件：")]),t._v(" "),e("ol",[e("li",[t._v("添加列不会从其他列读取现有值")]),t._v(" "),e("li",[t._v("删除列或者字段不会更改其他任何列的值")]),t._v(" "),e("li",[t._v("更新列或者字段不会更改其他任何列的值")]),t._v(" "),e("li",[t._v("更改列或者字段的排序不会更改与列或者字段关联的值")])]),t._v(" "),e("p",[t._v("Iceberg 使用 "),e("strong",[t._v("唯一ID")]),t._v(" 来跟踪表中的每一列。添加列时，会为其分配一个新的 ID，因此永远不会错误地使用现有数据")]),t._v(" "),e("h3",{attrs:{id:"分区演变"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分区演变"}},[t._v("#")]),t._v(" 分区演变")]),t._v(" "),e("p",[t._v("可以在现有表中更新 Iceberg 表的分区，因为查询不直接引用分区值。")]),t._v(" "),e("p",[t._v("在演变分区规范时，使用早期的规范写入的数据将保持不变，新数据则使用新的分区规范写入。每个分区版本的元数据都单独保留。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://gitee.com/GeiChan/picture/raw/master/img/partition-spec-evolution.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"排序顺序演变"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#排序顺序演变"}},[t._v("#")]),t._v(" 排序顺序演变")]),t._v(" "),e("p",[t._v("与分区规范类似，Iceberg 的排序顺序也可以在现有表中更新。当您演进一个排序顺序时，使用早期顺序写入的旧数据保持不变。引擎总是可以选择以最新的排序顺序写入数据，或者在排序成本过高时选择未排序的数据。")])])}),[],!1,null,null,null);v.default=a.exports}}]);